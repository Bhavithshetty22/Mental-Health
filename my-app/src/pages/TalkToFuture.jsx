// src/pages/TalkToFuture.jsx
import React, { useState } from "react";
import "./TalkToFuture.css";

export default function TalkToFuture() {
  const [situation, setSituation] = useState("");
  const [letter, setLetter] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  async function handleSubmit(e) {
    e.preventDefault();
    setError(null);
    setLetter(null);

    if (!situation.trim()) {
      setError("Please describe your situation.");
      return;
    }

    setLoading(true);
    try {
      const url = "http://localhost:5000/api/generate";
      const resp = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ situation }),
      });

      const raw = await resp.text();

      if (!resp.ok) {
        let errMsg;
        try {
          const parsed = JSON.parse(raw || "{}");
          errMsg = parsed?.error || parsed?.details || JSON.stringify(parsed);
        } catch {
          errMsg = raw || resp.statusText;
        }
        setError(`Server error ${resp.status}: ${errMsg}`);
        return;
      }

      if (!raw) {
        setError("Empty server response.");
        return;
      }

      let data;
      try {
        data = JSON.parse(raw);
      } catch {
        // backend returned plain text
        setLetter(raw);
        return;
      }

      if (data?.crisis) setLetter(data.message);
      else if (data?.letter) setLetter(data.letter);
      else setLetter(JSON.stringify(data));
    } catch (err) {
      console.error(err);
      setError("Network error. Make sure backend is running and URL is correct.");
    } finally {
      setLoading(false);
    }
  }

  function resetAll() {
    setSituation("");
    setLetter(null);
    setError(null);
  }

  // ---------- Helpers for PDF / Print ----------
  function escapeHtml(str = "") {
    return String(str)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function buildPrintableHtml(title = "Letter from future", body = "") {
    const safeBody = escapeHtml(body).replace(/\n/g, "<br/>");
    const now = new Date().toLocaleString();
    return `
      <!doctype html>
      <html>
        <head>
          <meta charset="utf-8"/>
          <title>${escapeHtml(title)}</title>
          <style>
            @page { margin: 20mm; }
            body { font-family: Georgia, 'Times New Roman', serif; color: #111; line-height:1.45; padding: 12px; background: #fff; }
            .wrapper { max-width: 720px; margin: 0 auto; padding: 24px; }
            h1 { font-size: 20px; margin-bottom: 6px; }
            .meta { color: #666; font-size: 12px; margin-bottom: 18px; }
            .body { font-size: 15px; white-space: pre-wrap; }
            footer { margin-top: 28px; font-size: 12px; color: #666; }
          </style>
        </head>
        <body>
          <div class="wrapper">
            <h1>${escapeHtml(title)}</h1>
            <div class="meta">Generated: ${escapeHtml(now)}</div>
            <div class="body">${safeBody}</div>
            <footer>Generated by MoodOra â€” supportive message.</footer>
          </div>
        </body>
      </html>
    `;
  }

  // Primary PDF generator: try jsPDF (direct file download)
  async function downloadAsPdf(filename = `future-letter-${Date.now()}.pdf`) {
    if (!letter) return;

    // try dynamic import of jsPDF
    try {
      const module = await import(/* webpackIgnore: true */ "jspdf").catch(() => null);
      const jsPDF = module?.jsPDF || (module && module.default && module.default.jsPDF) || module;
      if (jsPDF) {
        // Use jsPDF to create a multipage PDF
        const doc = new jsPDF({
          unit: "pt",
          format: "a4",
        });

        const margin = 40;
        const pageHeight = doc.internal.pageSize.getHeight();
        const maxLineWidth = doc.internal.pageSize.getWidth() - margin * 2;
        doc.setFont("Times", "Roman");
        doc.setFontSize(12);

        // split the text into lines that fit
        const lines = doc.splitTextToSize(letter, maxLineWidth);

        let cursorY = 60;

        for (let i = 0; i < lines.length; i++) {
          if (cursorY > pageHeight - 60) {
            doc.addPage();
            cursorY = 60;
          }
          doc.text(lines[i], margin, cursorY);
          cursorY += 16;
        }

        doc.save(filename);
        return;
      }
    } catch (err) {
      console.warn("jsPDF unavailable or failed:", err?.message || err);
      // fallthrough to print fallback
    }

    // Fallback: open printable HTML in an invisible iframe and call print
    fallbackPrintPdf(filename);
  }

  // Fallback approach: invisible iframe print (less popup-prone)
  function fallbackPrintPdf(filename) {
    if (!letter) return;
    const printHtml = buildPrintableHtml("A letter from your future self", letter);

    // remove any existing helper iframe
    const existing = document.getElementById("mf-print-iframe");
    if (existing) existing.remove();

    const iframe = document.createElement("iframe");
    iframe.id = "mf-print-iframe";
    iframe.style.position = "fixed";
    iframe.style.right = "0";
    iframe.style.bottom = "0";
    iframe.style.width = "1px";
    iframe.style.height = "1px";
    iframe.style.border = "0";
    iframe.style.opacity = "0";
    document.body.appendChild(iframe);

    const doc = iframe.contentWindow.document;
    doc.open();
    doc.write(printHtml);
    doc.close();

    // give the iframe a moment to render then call print
    iframe.onload = () => {
      try {
        iframe.contentWindow.focus();
        iframe.contentWindow.print();
        // optionally remove iframe after a short delay
        setTimeout(() => {
          try { iframe.remove(); } catch (e) {}
        }, 1000);
      } catch (err) {
        console.error("Fallback print failed:", err);
        alert("Printing failed. Try installing jsPDF (npm i jspdf) for direct download.");
        iframe.remove();
      }
    };

    // as a safety, also try print after slight delay if onload didn't run
    setTimeout(() => {
      try {
        iframe.contentWindow.focus();
        iframe.contentWindow.print();
        setTimeout(() => iframe.remove(), 1000);
      } catch (err) {
        // ignore
      }
    }, 600);
  }

  function downloadAsText(filename = `future-letter-${Date.now()}.txt`) {
    if (!letter) return;
    const blob = new Blob([letter], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  return (
    <div className="page-root vintage-root">
      <div className="card">
        <header className="card-header">
          <h1>Talk to Future</h1>
          <p className="subtitle">Tell your future self what's happening. Receive a calm, hopeful letter back.</p>
        </header>

        <form onSubmit={handleSubmit} className="form">
          <label className="label">Your current situation</label>
          <textarea
            value={situation}
            onChange={(e) => setSituation(e.target.value)}
            rows={7}
            placeholder="Type what's going onâ€”your worries, the problem, small details..."
          />

          <div className="actions">
            <button className="btn primary" type="submit" disabled={loading}>
              {loading ? "Writing..." : "Send to Future"}
            </button>

            <button className="btn ghost" type="button" onClick={resetAll}>
              Reset
            </button>
          </div>

          {error && <div className="error">{error}</div>}
        </form>

        {letter && (
          <>
            <section className="letter-wrap">
              <div className="parchment" role="region" aria-live="polite">
                <div className="torn-edge top" aria-hidden="true" />
                <div className="torn-edge bottom" aria-hidden="true" />

                <div className="parchment-inner">
                  <h2>A letter from your future self ðŸ’Œ</h2>
                  <div className="parchment-body" style={{ whiteSpace: "pre-wrap" }}>
                    {letter}
                  </div>
                </div>

                <div className="dust" aria-hidden="true" />
              </div>
            </section>

            {/* SMALL centered download controls under the letter */}
            <div className="download-controls">
              <button
                className="btn small"
                type="button"
                onClick={() => downloadAsPdf(`future-letter-${Date.now()}.pdf`)}
                title="Download as PDF"
              >
                PDF
              </button>

              <button
                className="btn small ghost"
                type="button"
                onClick={() => downloadAsText(`future-letter-${Date.now()}.txt`)}
                title="Download as text file"
              >
                TXT
              </button>

              <button
                className="btn small ghost"
                type="button"
                onClick={() => {
                  navigator.clipboard?.writeText(letter);
                  // small visual feedback
                  const prev = document.activeElement;
                  alert("Copied to clipboard");
                  prev?.focus?.();
                }}
                title="Copy to clipboard"
              >
                Copy
              </button>
            </div>
          </>
        )}

        <footer className="note">
          <strong>Note:</strong> This tool provides supportive messages only. If you or someone is in crisis, contact local emergency services or a crisis hotline immediately.
        </footer>
      </div>
    </div>
  );
}
